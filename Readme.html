<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
        document.ANALYSIS_DATA = ;
        document.CALLGRAPH = ;
        </script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/mcvoid/vm"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package vm provides a program-embeddable virtual machine which can
execute scripts which act upon io.Reader and io.Writer.
</p>
<p>
Features
- A hot-swappable instruction set.
- STDIN, STDOUT, STDERR readable and writable to any io.Reader or io.Writer
- Adjustable memory size
- Enable scripting into your Go app.
</p>
<p>
How to use:
- import &#34;github.com/mcvoid/vm&#34;
- vm, err := vm.New(1024)
- prog := vm.Program{vm.Push, 3, vm.Push, 5, vm.Add, vm.Print, 1, vm.Halt}
- vm.Run(prog, 0, false)
- Watch it print &#34;8&#34; to vm.Stdout (os.Stdout by default)
</p>
<p>
What it can&#39;t do:
- compile a higher-level language to machine code (maybe in a separate package)
- Stack bounds checking (Go has bounds checking, though, so it will just panic on overflow)
- Printing ASCII/UTF-8 (yet)
- Reading from Stdin (yet)
- Self-modifying code (code and stack reside in different areas)
- Multi-word return values (maybe in the future)
- Not even remotely thread-safe. Use different VM&#39;s to execute code concurrently.
</p>
<p>
What it can do:
- Function calls.
- Fibonacci numbers! Ackermann functions! Factorials!
- Tail recursion.
- Add your own instructions to make it do more.
- Hook vm.Stdout to an http.ResponseWriter to script your web apps!
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
			
				
				<dd><a href="#Bitbucket">type Bitbucket</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Bitbucket.Write">func (bit Bitbucket) Write(b []byte) (n int, err error)</a></dd>
				
			
				
				<dd><a href="#Instruction">type Instruction</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Instruction.String">func (i Instruction) String() string</a></dd>
				
			
				
				<dd><a href="#InstructionSet">type InstructionSet</a></dd>
				
				
			
				
				<dd><a href="#Program">type Program</a></dd>
				
				
			
				
				<dd><a href="#VM">type VM</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#New">func New(size int) (vm *VM, err error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VM.Pop">func (vm *VM) Pop() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#VM.Push">func (vm *VM) Push(val int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#VM.Run">func (vm *VM) Run(src Program, start int)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/pkg/github.com/mcvoid/vm/instr.go">instr.go</a>
			
				<a href="/src/pkg/github.com/mcvoid/vm/vm.go">vm.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
                        <p>
                          In the call graph viewer below, each node
                          is a function belonging to this package
                          and its children are the functions it
                          calls&mdash;perhaps dynamically.
                        </p>
                        <p>
                          The root nodes are the entry points of the
                          package: functions that may be called from
                          outside the package.  
                          There may be non-exported or anonymous
                          functions among them if they are called
                          dynamically from another package.
                        </p>
                        <p>
                          Click a node to visit that function's source code.
                          From there you can visit its callers by
                          clicking its declaring <code>func</code>
                          token.
                        </p>
                        <p>
                          Functions may be omitted if they were
                          determined to be unreachable in the
                          particular programs or tests that were
                          analyzed.
                        </p>
                        <!-- Zero means show all package entry points. -->
                        <ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
                        </script>                        
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    <span class="comment">/*
       Halt tells the VM to stop executing the current program.
       syntax: halt
    */</span>
    <span id="Halt">Halt</span> <a href="/pkg/builtin/#int">int</a> = <a href="/pkg/builtin/#iota">iota</a>
    <span class="comment">/*
       Load reads a value from Memory address addr and Pushes it on the stack.
       syntax: load &lt;addr&gt;
    */</span>
    <span id="Load">Load</span>
    <span class="comment">/*
        Store pops a value from the stack and writes it to Memory at address addr.
        syntax: store &lt;addr&gt;
    */</span>
    <span id="Store">Store</span>
    <span class="comment">/*
       LoadArg Pushes the nth argument to the stack.
       syntax: loadarg &lt;n&gt;
    */</span>
    <span id="LoadArg">LoadArg</span>
    <span class="comment">/*
       StorArg pops a value from the stack and stores it in the nth argument.
       syntax: storarg &lt;n&gt;
    */</span>
    <span id="StoreArg">StoreArg</span>
    <span class="comment">/*
       Add pops two values from the stack and Pushes the sum of those values.
       syntax: add
    */</span>
    <span id="Add">Add</span>
    <span class="comment">/*
       Substract pops two values from the stack and Pushes the difference of the second value popped minus the first.
       syntax: sub
    */</span>
    <span id="Subtract">Subtract</span>
    <span class="comment">/*
       Multiply pops two values from the stack and Pushes the product of the two..
       syntax: mul
    */</span>
    <span id="Multiply">Multiply</span>
    <span class="comment">/*
       Divide pops two values from the stack and returns the quotient of the two values minus the remainder.
       syntax: div
    */</span>
    <span id="Divide">Divide</span>
    <span class="comment">/*
       Modulo pops two values from the stack, divides them, and returns the quotient of the two values.
       syntax: mod
    */</span>
    <span id="Modulo">Modulo</span>
    <span class="comment">/*
       And pops two values from the stack and returns the bitwise-and of them.
       syntax: and
    */</span>
    <span id="And">And</span>
    <span class="comment">/*
       Or pops two values from the stack and returns the bitwise-or of them.
       syntax: or
    */</span>
    <span id="Or">Or</span>
    <span class="comment">/*
       Xor pops two values from the stack and returns the bitwise-xor of them.
       syntax: xor
    */</span>
    <span id="Xor">Xor</span>
    <span class="comment">/*
       Not pops two values from the stack and returns the bitwise-not of them.
       syntax: not
    */</span>
    <span id="Not">Not</span>
    <span class="comment">/*
        ShiftLeft pops two values from the stack and returns the first value, shifted
        to the left a number of bits as the second value.
        syntax: shl
    */</span>
    <span id="ShiftLeft">ShiftLeft</span>
    <span class="comment">/*
        ShiftRight pops two values from the stack and returns the first value,
        logically shifted to the left a number of bits as the second value.
        syntax: shr
    */</span>
    <span id="ShiftRight">ShiftRight</span>
    <span class="comment">/*
       Pushes a literal value to the stack.
       syntax: Push &lt;val&gt;
    */</span>
    <span id="Push">Push</span>
    <span class="comment">/*
       Pops a value from the stack, discarding it.
       syntax: pop
    */</span>
    <span id="Pop">Pop</span>
    <span class="comment">/*
       JumpIfZero Pops a value from the stack. If the value is zero, it branches to addr.
       syntax: jz &lt;addr&gt;
    */</span>
    <span id="JumpIfZero">JumpIfZero</span>
    <span class="comment">/*
       JumpIfNotZero pops a value from the stack. If the value is not zero, it branches to addr.
       syntax: jnz &lt;addr&gt;
    */</span>
    <span id="JumpIfNotZero">JumpIfNotZero</span>
    <span class="comment">/*
       Calls a function with n arguments at address addr.
       syntax: call &lt;addr&gt; &lt;n&gt;
    */</span>
    <span id="Call">Call</span>
    <span class="comment">/*
       Pops a value from the current stack frame, returns from the function, and Pushes the value back.
       syntax: ret
    */</span>
    <span id="Return">Return</span>
    <span class="comment">/*
       Prints n values to the console.
       syntax: print &lt;n&gt;
    */</span>
    <span id="Print">Print</span>
)</pre>
				<p>
Instructions built-in to the Default instruction set.
</p>

			
		
		
		
		
			
			
			<h2 id="Bitbucket">type <a href="/src/pkg/target/vm.go?s=2516:2539#L53">Bitbucket</a></h2>
			<pre>type Bitbucket struct{}</pre>
			<p>
A fake io.Writer which discards everything written to it, like /dev/null.
Useful for suppressing a VM&#39;s output on Stdout or Stderr.
</p>


			

			

			
			
			

			

			
				
				<h3 id="Bitbucket.Write">func (Bitbucket) <a href="/src/pkg/target/vm.go?s=2540:2594#L54">Write</a></h3>
				<pre>func (bit <a href="#Bitbucket">Bitbucket</a>) Write(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			        
			
		
			
			
			<h2 id="Instruction">type <a href="/src/pkg/target/instr.go?s=2854:3380#L120">Instruction</a></h2>
			<pre>type Instruction struct {
    <span class="comment">// Action is the code which is called that is executed upon the vm to change its state.</span>
    <span class="comment">// args is any arguments to the instruction which follow in the bytecode.</span>
    <span class="comment">// len(args) = Args</span>
    Action func(vm *<a href="#VM">VM</a>, args []<a href="/pkg/builtin/#int">int</a>)
    Text   <a href="/pkg/builtin/#string">string</a> <span class="comment">// Text is the textual representaion of the instruction as seen in stack traces.</span>
    Args   <a href="/pkg/builtin/#int">int</a>    <span class="comment">// Args tells the VM how many arguments to pull from the code.</span>
    Halts  <a href="/pkg/builtin/#bool">bool</a>   <span class="comment">// Halts determines whether the instruction halts execution after running this instruction.</span>
}</pre>
			<p>
Instruction contains critical information about a single instruction for the VM.
</p>


			

			

			
			
			

			

			
				
				<h3 id="Instruction.String">func (Instruction) <a href="/src/pkg/target/instr.go?s=3427:3463#L131">String</a></h3>
				<pre>func (i <a href="#Instruction">Instruction</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
Represents an instruction in string form.
</p>

				
				
			        
			
		
			
			
			<h2 id="InstructionSet">type <a href="/src/pkg/target/instr.go?s=3584:3617#L136">InstructionSet</a></h2>
			<pre>type InstructionSet []<a href="#Instruction">Instruction</a></pre>
			<p>
InstructionSet is a collection of all of the instructions the VM can execute in a given program.
</p>


			

			
				<pre>var <span id="Default">Default</span> <a href="#InstructionSet">InstructionSet</a></pre>
				<p>
The behavior of each bytecode
</p>

			

			
			
			

			

			
		
			
			
			<h2 id="Program">type <a href="/src/pkg/target/vm.go?s=2358:2376#L49">Program</a></h2>
			<pre>type Program []<a href="/pkg/builtin/#int">int</a></pre>
			<p>
A program is a sequence of integers.
Instructions, offsets, and literal values are all integers.
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="VM">type <a href="/src/pkg/target/vm.go?s=1374:2253#L36">VM</a></h2>
			<pre>type VM struct {
    Mem    []<a href="/pkg/builtin/#int">int</a>          <span class="comment">// Mem represents the  internal Memory of the VM. It does not include code.</span>
    SP     <a href="/pkg/builtin/#int">int</a>            <span class="comment">// SP, or the stack pointer, is the address of the top of the stack. It points to the next available unused space.</span>
    FP     <a href="/pkg/builtin/#int">int</a>            <span class="comment">// FP, or the frame pointer, is the address of the start of the current function&#39;s stack frame.</span>
    IP     <a href="/pkg/builtin/#int">int</a>            <span class="comment">// IP, or the instruction pointer, is the address of the next instruction to execute.</span>
    IS     <a href="#InstructionSet">InstructionSet</a> <span class="comment">// The set of instructions which can be executed on this VM.</span>
    Stdin  <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>      <span class="comment">// Stdin is the VM&#39;s standard input reader. This is the reader which Read reads from.</span>
    Stdout <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>      <span class="comment">// Stdout is the VM&#39;s standard output writer. This is what Print writes to.</span>
    Stderr <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>      <span class="comment">// Stderr is the VM&#39;s standard error writer. This is what stack traces write to.</span>
}</pre>
			<p>
VM represents the state of a virtual machine.
Mem and the memory in which code resides are separate spaces.
</p>


			

			

			
			
			

			
				
				<h3 id="New">func <a href="/src/pkg/target/vm.go?s=2867:2905#L60">New</a></h3>
				<pre>func New(size <a href="/pkg/builtin/#int">int</a>) (vm *<a href="#VM">VM</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
New creates a new virtual machine.
</p>
<p>
size is the size of the VM&#39;s stack memory in words. This does not include the memory used by code, so available stack size is unaffected
by program size. The size of a word is the same size as an int.
</p>

				
			        
			

			
				
				<h3 id="VM.Pop">func (*VM) <a href="/src/pkg/target/vm.go?s=4116:4139#L107">Pop</a></h3>
				<pre>func (vm *<a href="#VM">VM</a>) Pop() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Pop pops a value from the stack, updating SP accordingly and in the correct sequence.
</p>

				
				
			        
			
				
				<h3 id="VM.Push">func (*VM) <a href="/src/pkg/target/vm.go?s=3964:3991#L101">Push</a></h3>
				<pre>func (vm *<a href="#VM">VM</a>) Push(val <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Push pushes a value to the stack, updating SP accordingly and in the correct sequence.
</p>

				
				
			        
			
				
				<h3 id="VM.Run">func (*VM) <a href="/src/pkg/target/vm.go?s=3253:3294#L77">Run</a></h3>
				<pre>func (vm *<a href="#VM">VM</a>) Run(src <a href="#Program">Program</a>, start <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Runs a program on the VM
src is the source of the bytecode
start is the index of the code starting point
</p>

				
				
			        
			
		
	

	





